<!doctype html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=""> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8" lang=""> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9" lang=""> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="">
<!--<![endif]-->

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Dynamic Notes</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../css/bootstrap.min.css">
  <link rel="stylesheet" href="../css/main.css">
  <script src="../js/vendor/modernizr-2.8.3-respond-1.4.2.min.js"></script>
</head>

<body>

  <!-- Main jumbotron for a primary marketing message or call to action -->
  <div class="jumbotron">
    <div class="container">
      <h2>Speaking Javascript 2nd Pass</h2>
    </div>
  </div>

  <div class="container">

    
<div class='text'>

<!--
'use strict'

function log(...args){
  console.log(...args)
}

-->

</div>
<div class='text'>
 

<div class='header'>
 <span>Named blocks</span> 
</div>


</div>
<div class='code'>
<div>leBlock:&nbsp;{</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;1</div>
<div>&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"outer&nbsp;loop"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"inner&nbsp;loop"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;leBlock</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;}</div>
<div>&nbsp;&nbsp;}</div>
<div>&nbsp;</div>
<div>}</div>
<div>&nbsp;</div>
<div><span class='glyphicon glyphicon-arrow-right'></span>&nbsp;outer&nbsp;loop</div>
<div><span class='glyphicon glyphicon-arrow-right'></span>&nbsp;inner&nbsp;loop</div>

</div>
<div class='text'>
 

<div class='header'>
 <span>JavaScript has only six types</span> 
</div>

<ul>
  <li>Undefined, Null</li> 
  <li>Boolean, String, Number</li> 
  <li>Object</li> 
</ul>

<p>
Therefore, constructors technically don’t introduce new types, even though
they are said to have instances.
</p>

<div class='header'>
 <span>Primitive Values</span> 
</div>
<ul>
<li>Compared by value: the content is compared</li>
<li>Always immutable: properties can't be changed, added, or removed</li>
</ul>

<div class='header'>
 <span>Object Values</span> 
</div>
<ul>
<li>All non-primitive values are objects </li>
<li>Types</li>
<ul>
<li>Plain Objects</li>
<li>Arrays</li>
<li>Regular Expressions</li>
</ul>
<li>Compared by reference</li>
<li>Mutable by default</li>
</ul>


<div class='header'>
 <span>False</span> 
</div>
<ul>
<li>undefined and null</li>
<li>0</li>
<li>NaN</li>
<li>''</li>
</ul>

<div class='header'>
 <span>Primitives Borrow Their Methods from Wrappers</span> 
 <ul>
<li>In strict mode, methods from the wrapper prototype are used transparently</li>
 </ul>
</div>

</div>
<div class='code'>
<div><span class='string'>"abc"</span>.charAt&nbsp;===&nbsp;String.prototype.charAt&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;true</div>
<div>&nbsp;</div>
<div>String.prototype.hello&nbsp;=&nbsp;()&nbsp;=>&nbsp;log(<span class='string'>"hello"</span>)</div>
<div><span class='string'>"abc"</span>.hello()&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;hello</div>

</div>
<div class='text'>

<blockquote>
Technically, primitive values do not have their own properties, they borrow
them from wrapper constructors. But that is something that goes on behind the
scenes, so you don’t normally see it.
</blockquote>

</div>
<div class='text'>

<blockquote>
the + operator examines its operands. If one of them is a string, the other is
also converted to a string and both are concatenated, Otherwise, both operands
are converted to numbers (see Converting to Number) and added:
</blockquote>

</div>
<div class='code'>
<div><span class='string'>"foo"</span>&nbsp;+&nbsp;3&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;<span class='string'>'foo3'</span></div>
<div>3&nbsp;+&nbsp;true&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;4</div>

</div>
<div class='text'>

<blockquote>
The typeof operator distinguishes primitives from objects and determines the
types of primitives.
</blockquote>

<blockquote>
The instanceof operator determines whether an object is an instance of a given
constructor.
</blockquote>

</div>
<div class='text'>

<div class='header'>
 <span>Typeof bug</span> 
</div>

</div>
<div class='code'>
<div>typeof&nbsp;null&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;<span class='string'>'object'</span></div>

</div>
<div class='text'>

<div class='header'>
 <span>NaN is the only value that is not equal to itself</span> 
</div>

</div>
<div class='code'>
<div>NaN&nbsp;===&nbsp;NaN&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;false</div>

</div>
<div class='text'>

<div class='header'>
 <span>Newer engines optimize string concatenation via + and use a similar
 method internally. Therefore, the plus operator is faster on those
 engines</span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>substring() should be avoided in favor of slice(), which is similar, but
 can handle negative positions and is implemented more consistently across
 browsers.</span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>Extract a length of string from a string</span> 
</div>
<ul>
<li>str.substr( beginIndex [, length] ) takes optionsl <b>string length</b></li>
<li>str.slice( beginIndex [, endIndex] ) takes optional <b>end index</b></li>
<li>Extract single character with str[0] or str.charAt(0)</li>
<li>str.split( [separator [, limit] ])</li>
<ul>
<li>If separator is undefined split returns entire string (seems useless)</li>
<li>If separater is '' returns array of every character.</li>
<li>Can be a regex</li>
<li>If regex has groups the matches are included, shown below</li>
</ul>
</ul>

</div>
<div class='code'>
<div><span class='comment'>//&nbsp;if&nbsp;multiple&nbsp;separators,&nbsp;we&nbsp;can&nbsp;preserve&nbsp;them&nbsp;to&nbsp;reconstruct&nbsp;string</span></div>
<div>let&nbsp;strA&nbsp;=&nbsp;<span class='string'>"a,b.c|d,e.f|"</span></div>
<div>let&nbsp;a&nbsp;=&nbsp;strA.split(/([,.\|])/)</div>
<div>log(a)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;<span class='string'>'a'</span>,&nbsp;<span class='string'>','</span>,&nbsp;<span class='string'>'b'</span>,&nbsp;<span class='string'>'.'</span>,&nbsp;<span class='string'>'c'</span>,&nbsp;<span class='string'>'|'</span>,&nbsp;<span class='string'>'d'</span>,&nbsp;<span class='string'>','</span>,&nbsp;<span class='string'>'e'</span>,&nbsp;<span class='string'>'.'</span>,&nbsp;<span class='string'>'f'</span>,&nbsp;<span class='string'>'|'</span>,&nbsp;<span class='string'>''</span>&nbsp;]</div>
<div>&nbsp;</div>
<div>let&nbsp;strB&nbsp;=&nbsp;a.join(<span class='string'>""</span>)</div>
<div>log(strB)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;<span class='string'>'a,b.c|d,e.f|'</span></div>
<div>&nbsp;</div>
<div>log(strA&nbsp;===&nbsp;strB)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;true</div>

</div>
<div class='text'>

<div class='header'>
 <span>Transforming a string, all non-destructive</span> 
</div>
<ul>
<li>' abc'.trim() removes whitespace from beginning and end.</li>
<li>str.toLowerCase()</li>
<li>str.toUpperCase()</li>
<li>str.concat(str [, str2 [, str3]])</li>
<ul>
<li>'abc'.concat() results in 'abcundefined' if x is undefined, so make sure
its initiated with x='' </li>
</ul>
</ul>

</div>
<div class='text'>

<div class='header'>
 <span>Search and Compare</span> 
</div>
<ul>
<li>str.indexOf(searchStr, position=0)</li>
<ul>
<li>Returns position if found, -1 if nothing found.</li>
<li>searchStr <b>cannot</b> a regex</li>
<li>case sensitive</li>
<li>/b/.test(str) is better than str.indexOf('b') >=0 </li>
</ul>
<li>str.search(regex)</li>
<ul>
<li>Like indexOf returns position of first match or -1</li>
<li>Will convert string parameter to regex</li>
<li>Unlike indexOf doesn't take an position</li>
</ul>
</ul>

</div>
<div class='code'>
<div><span class='comment'>//&nbsp;does&nbsp;<span class='string'>'b'</span>&nbsp;exist&nbsp;in&nbsp;str?</span></div>
<div><span class='comment'>//&nbsp;sucks</span></div>
<div>log(<span class='string'>"abc"</span>.indexOf(<span class='string'>"b"</span>)&nbsp;>=&nbsp;0)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;true</div>
<div><span class='comment'>//&nbsp;better</span></div>
<div>log(/b/.test(<span class='string'>"abc"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;true</div>
<div>&nbsp;</div>
<div>log(<span class='string'>"abc"</span>.search(/b/))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;1</div>
<div>log(<span class='string'>"abc"</span>.search(<span class='string'>"b"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;1</div>
<div>log(<span class='string'>"abc"</span>.search(/B/))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;-1</div>

</div>
<div class='text'>

<div class='header'>
 <span>Test, Match and Replace with Regex</span> 
</div>
<ul>
<li>str.match(regex)</li>
<ul>
<li>Like str.search() takes or converts regex argument</li>
<li>Capture groups or return all matching substrings</li>
<li>Returns match group if <b>no</b> /g flag</li>
<li>Returns array of all matches if /g set</li>
</ul>
<li>str.replace(regexp|substr, newSubstr|function)
</li>
<ul>
<li>If first argument is a string it is NOT interpreted as a regex, unlike
match() and search()</li>
<li>Unless first argument is a regex/g it will only replace first match</li>
<li>The replacement function parameters are complicated, but the first position
is the match value</li>
<li>The replacement string can contain patters starting with $</li>
<ul>
<li>$$ inserts a $</li>
<li>$& inserts the matched substring</li>
<li>$` Inserts the portion of the string that precedes the matched substring.</li>
<li>$' Inserts the portion of the string that follows the matched substring.</li>
<li>$n Where n is a positive integer less than 100, inserts the nth
parenthesized submatch string, provided the first argument was a RegExp object.
Note that this is 1-indexed.</li>
</ul>
</ul>
</ul>

</div>
<div class='code'>
<div>log(<span class='string'>"abc"</span>.match(/B/))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;null</div>
<div>log(<span class='string'>"abc"</span>.match(/b/))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;<span class='string'>'b'</span>,&nbsp;index:&nbsp;1,&nbsp;input:&nbsp;<span class='string'>'abc'</span>&nbsp;]</div>
<div>log(<span class='string'>"abc"</span>.match(<span class='string'>"b"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;<span class='string'>'b'</span>,&nbsp;index:&nbsp;1,&nbsp;input:&nbsp;<span class='string'>'abc'</span>&nbsp;]</div>
<div>log(<span class='string'>"abc"</span>.match(/b/g))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;<span class='string'>'b'</span>&nbsp;]</div>
<div>log(<span class='string'>"abcbc"</span>.match(/b/g))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;<span class='string'>'b'</span>,&nbsp;<span class='string'>'b'</span>&nbsp;]</div>
<div>&nbsp;</div>
<div>log(<span class='string'>"abc"</span>.replace(<span class='string'>"a"</span>,&nbsp;<span class='string'>"A"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;Abc</div>
<div>log(<span class='string'>"abc"</span>.replace(/a/,&nbsp;<span class='string'>"A"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;Abc</div>
<div>log(<span class='string'>"abcabc"</span>.replace(/a/,&nbsp;<span class='string'>"A"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;Abcabc</div>
<div>log(<span class='string'>"abcabc"</span>.replace(/a/g,&nbsp;<span class='string'>"A"</span>))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;AbcAbc</div>
<div>&nbsp;</div>
<div><span class='string'>"abc"</span>.replace(/a/,&nbsp;x&nbsp;=>&nbsp;log(`found&nbsp;${x}`))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;found&nbsp;a</div>
<div><span class='string'>"abc"</span>.replace(/(a)/,&nbsp;(x,&nbsp;p1,&nbsp;offset,&nbsp;whole)&nbsp;=>&nbsp;{</div>
<div>&nbsp;&nbsp;log(`found&nbsp;${x}&nbsp;${p1}&nbsp;${offset}&nbsp;${whole}`)</div>
<div>})&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;found&nbsp;a&nbsp;a&nbsp;0&nbsp;abc</div>

</div>
<div class='text'>

<div class='header'>
 <span>JS has a do-while loop, that I keep forgetting about.</span> 
</div>

</div>
<div class='code'>
<div>let&nbsp;i&nbsp;=&nbsp;0,</div>
<div>&nbsp;&nbsp;a&nbsp;=&nbsp;[]</div>
<div>do&nbsp;{</div>
<div>&nbsp;&nbsp;a.push(i++)</div>
<div>}&nbsp;while&nbsp;(i&nbsp;< 10)</div>
<div>log(a)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9&nbsp;]</div>

</div>
<div class='text'>

<div class='header'>
 <span>Best practice: don’t use for-in for arrays and be careful with objects</span> 
</div>
<ul>
<li>iterates over indices not values, so we just get 0,1,2,3,4... </li>
<li>iteration includes properties added to array</li>
<li>use [].forEach instead of for-in for arrays</li>
<li>iterates over all enumerable properties, including inherited ones</li>
</ul>

</div>
<div class='text'>

<div class='header'>
 <span>switch statement</span> 
</div>
<ul>
<li>evaluates expression and jumps to matching cases, finding it using ===</li>
<li>case can be an expression</li>
<li>cases are fall through, so you need to break</li>
<li>Use fallthrough to combine multple cases </li>
</ul>

</div>
<div class='code'>
<div><span class='comment'>//&nbsp;case&nbsp;value&nbsp;can&nbsp;be&nbsp;any&nbsp;evaluated&nbsp;expression</span></div>
<div>switch&nbsp;(<span class='string'>"red"</span>)&nbsp;{</div>
<div>&nbsp;&nbsp;case&nbsp;<span class='string'>"blue"</span>:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"color&nbsp;is&nbsp;blue"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;case&nbsp;[<span class='string'>"r"</span>,&nbsp;<span class='string'>"e"</span>,&nbsp;<span class='string'>"d"</span>].join(<span class='string'>""</span>):</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"color&nbsp;is&nbsp;red"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;default:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"not&nbsp;found"</span>)</div>
<div>}&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;color&nbsp;is&nbsp;red</div>
<div>&nbsp;</div>
<div><span class='comment'>//&nbsp;use&nbsp;fallthrough&nbsp;for&nbsp;multiple&nbsp;conditions</span></div>
<div>switch&nbsp;(<span class='string'>"red"</span>)&nbsp;{</div>
<div>&nbsp;&nbsp;case&nbsp;<span class='string'>"red"</span>:</div>
<div>&nbsp;&nbsp;case&nbsp;<span class='string'>"white"</span>:</div>
<div>&nbsp;&nbsp;case&nbsp;<span class='string'>"blue"</span>:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"color&nbsp;is&nbsp;american"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;default:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"unamerican"</span>)</div>
<div>}&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;color&nbsp;is&nbsp;american</div>
<div>&nbsp;</div>
<div><span class='comment'>//&nbsp;use&nbsp;instead&nbsp;of&nbsp;confusing&nbsp;if&nbsp;else&nbsp;if&nbsp;else&nbsp;chains</span></div>
<div>&nbsp;</div>
<div>let&nbsp;x&nbsp;=&nbsp;10000</div>
<div>switch&nbsp;(true)&nbsp;{</div>
<div>&nbsp;&nbsp;case&nbsp;x&nbsp;< 10:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"small&nbsp;number"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;case&nbsp;x&nbsp;< 100:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"sizable&nbsp;number"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;case&nbsp;x&nbsp;< 1000:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"big&nbsp;number"</span>)</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;break</div>
<div>&nbsp;&nbsp;default:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;log(<span class='string'>"huge&nbsp;number"</span>)</div>
<div>}</div>

</div>
<div class='text'>

<div class='header'>
 <span>Don't throw just anything</span> 
</div>
<p>
JavaScript has special constructors for exception objects . Use those or
subclass them. Their advantage is that JavaScript automatically adds a stack
trace (on most engines) and that they have room for additional context-specific
properties. The simplest solution is to use the built-in constructor Error():
</p>
<p>
When Error is used like a function -- without new, it will return an Error
object. Therefore, a mere call to Error will produce the same output that
constructing an Error object via the new keyword would.
</p>
<p>
  Optional finally clause, it is always called, even if try has a return statement.
  Can be used for function cleanup.
</p>

</div>
<div class='code'>
<div>try&nbsp;{</div>
<div>&nbsp;&nbsp;throw&nbsp;Error(<span class='string'>"help"</span>)&nbsp;</div>
<div>}&nbsp;catch&nbsp;(e)&nbsp;{</div>
<div>&nbsp;&nbsp;log(<span class='string'>"caught&nbsp;"</span>,&nbsp;e.stack)</div>
<div>}&nbsp;finally&nbsp;{</div>
<div>&nbsp;&nbsp;log(<span class='string'>"always"</span>)</div>
<div>}</div>

</div>
<div class='text'>

<div class='header'>
 <span>If you don't return anything from a function undefined is returned</span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>
 new is another way to call any function, but not always appriopriate
 </span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>
  Functional expressions can be named 
  </span> 
</div>
<ul>
<li>But the name can only be accessed within the function itself</li>
<li>Not sure if f.name property is reliably supported in this situation.</li>
</ul>

</div>
<div class='code'>
<div>let&nbsp;f&nbsp;=&nbsp;function&nbsp;me()&nbsp;{</div>
<div>&nbsp;&nbsp;console.log(me)</div>
<div>}</div>
<div>&nbsp;</div>
<div>f()&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;[Function:&nbsp;me]</div>
<div>console.log(me)&nbsp;<span class='glyphicon glyphicon-fire' style='color:orange'></span>&nbsp;ReferenceError:&nbsp;me&nbsp;is&nbsp;not&nbsp;defined</div>
<div>console.log(f.name)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;f</div>

</div>
<div class='text'>

<div class='header'>
 <span>
  Way to write iffys that doesn't confuse prettier
  </span> 
</div>

</div>
<div class='code'>
<div>!!(function()&nbsp;{</div>
<div>&nbsp;&nbsp;console.log(<span class='string'>"hi"</span>)</div>
<div>})()&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;hi</div>

</div>
<div class='text'>

<div class='header'>
 <span>
   delete deletes a property from an object
  </span> 
  <ul>
    <li>
      delete affects only the direct (“own,” noninherited) properties of an
      object. Its prototypes are not touched
    </li>
    <li>
      Use the delete operator sparingly. Most modern JavaScript engines
      optimize the performance of instances created by constructors if their
      “shape” doesn’t change (roughly: no properties are removed or added).
      Deleting a property prevents that optimization.
    </li>
  </ul>
</div>

</div>
<div class='code'>
<div>let&nbsp;o&nbsp;=&nbsp;{a:&nbsp;1}</div>
<div>delete&nbsp;o.a</div>
<div>log(o)&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;{}</div>

</div>
<div class='text'>

<div class='header'>
 <span>
   Avoid the object constructor; an empty object literal is almost always a better choice
  </span> 
</div>

</div>
<div class='code'>
<div>var&nbsp;obj&nbsp;=&nbsp;<span class='highlight'>new</span>&nbsp;Object()&nbsp;<span class='comment'>//&nbsp;AVOID&nbsp;</span></div>
<div>var&nbsp;obj&nbsp;=&nbsp;{}&nbsp;<span class='comment'>//&nbsp;prefer</span></div>

</div>
<div class='text'>

<div class='header'>
 <span>
   When you call a function, <strong>this</strong> is always an (implicit) parameter:
  </span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>
    Function.prototype.call calls a function. <br />
    Function.prototype.bind returns a new function. <br />
    Function.prototype.apply is now obsolete.
  </span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>
   Fancy term for Function.prototype.bind is <i>partial function application</i>
  </span> 
</div>

</div>
<div class='text'>

<div class='header'>
 <span>
  Proper way to extract a method.
  </span> 
</div>

</div>
<div class='code'>
<div>let&nbsp;o&nbsp;=&nbsp;{</div>
<div>&nbsp;&nbsp;x:&nbsp;1,</div>
<div>&nbsp;&nbsp;add:&nbsp;function(x)&nbsp;{</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;+&nbsp;1</div>
<div>&nbsp;&nbsp;}</div>
<div>}</div>
<div>&nbsp;</div>
<div>let&nbsp;a1&nbsp;=&nbsp;o.add.bind(o)</div>
<div>&nbsp;</div>
<div>log(a1(3))&nbsp;<span class='glyphicon glyphicon-arrow-right'></span>&nbsp;4</div>

</div>
<div class='text'>

<div class='header'>
 <span>
  forEach description and analysis
  </span> 
</div>

</div>
<div class='text'>

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

</div>

  </div> <!-- /container -->

  <script src="../js/vendor/jquery-1.11.2.min.js">
  <script src="../js/vendor/bootstrap.min.js"></script>

</body>

</html>
